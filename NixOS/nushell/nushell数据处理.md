# [加载数据](https://www.nushell.sh/zh-CN/book/loading_data.html#加载数据)

之前我们使用了[`ls`](https://www.nushell.sh/commands/docs/ls.html)、[`ps`](https://www.nushell.sh/commands/docs/ps.html)、[`date`](https://www.nushell.sh/commands/docs/date.html)和[`sys`](https://www.nushell.sh/commands/docs/sys.html)等命令来加载关于文件、进程、日期时间和系统本身的信息。每条命令都会给我们提供一个信息表，以对其进行探索。我们也可以通过其他方式将数据载入表格以供使用。

## [打开文件](https://www.nushell.sh/zh-CN/book/loading_data.html#打开文件)

Nu 在处理数据方面最强大的能力之一是[`open`](https://www.nushell.sh/commands/docs/open.html)命令。它是一个多功能命令，可以处理许多不同的数据格式。为了说明这一点让我们试着打开一个 JSON 文件：

```
> open editors/vscode/package.json
──────────────────┬───────────────────────────────────────────────────────────────────────────────
 name             │ lark
 description      │ Lark support for VS Code
 author           │ Lark developers
 license          │ MIT
 version          │ 1.0.0
 repository       │ [row type url]
 publisher        │ vscode
 categories       │ [table 0 rows]
 keywords         │ [table 1 rows]
 engines          │ [row vscode]
 activationEvents │ [table 1 rows]
 main             │ ./out/extension
 contributes      │ [row configuration grammars languages]
 scripts          │ [row compile postinstall test vscode:prepublish watch]
 devDependencies  │ [row @types/mocha @types/node tslint typescript vscode vscode-languageclient]
──────────────────┴───────────────────────────────────────────────────────────────────────────────
```

与[`ls`](https://www.nushell.sh/commands/docs/ls.html)类似，打开一个 Nu 支持的文件类型，会返回一些不仅仅是文本（或一个字节流）的东西。这里我们打开了一个来自 JavaScript 项目的 "package.json" 文件。Nu 可以识别 JSON 文本并将其解析为一个数据表。

如果我们想查看当前项目的版本，我们可以使用[`get`](https://www.nushell.sh/commands/docs/get.html)命令：

```
> open editors/vscode/package.json | get version
1.0.0
```

Nu 目前支持直接从以下格式加载表数据：

- csv
- eml
- ics
- ini
- json
- nuon
- ods
- ssv
- toml
- tsv
- url
- vcf
- xlsx / xls
- xml
- yaml / yml

但是，当你加载其他的文本文件时会发生什么呢？让我们试一试：

```
> open README.md
```

我们会看到该文件的内容。

本质上，这些文本文件对 Nu 来说就是一个大字符串。接下来，我们将讨论如何处理这些字符串，以便从中获得我们需要的数据。

## [处理字符串](https://www.nushell.sh/zh-CN/book/loading_data.html#处理字符串)

处理来自 Nu 外部数据时一个普遍情况是，它并不总是以 Nu 理解的格式出现。通常这些数据是以字符串的形式提供给我们的。

想象一下，我们得到了这个数据文件：

```
> open people.txt
Octavia | Butler | Writer
Bob | Ross | Painter
Antonio | Vivaldi | Composer
```

我们想要的数据都由管道（`|`）符号隔开，每人单独一行。由于 Nu 没有默认的以管道分隔的文件格式，所以我们必须自己来解析。

当我们引入这个文件时，我们需要做的第一件事是确保后续每次只处理一行：

```
> open people.txt | lines
───┬──────────────────────────────
 0 │ Octavia | Butler | Writer
 1 │ Bob | Ross | Painter
 2 │ Antonio | Vivaldi | Composer
───┴──────────────────────────────
```

可以看到，我们正在处理这些行，因为我们又回到了一个列表中。下一步是看看是否可以把行分割成更有用的东西。为此，我们将使用[`split`](https://www.nushell.sh/commands/docs/split.html)命令。[`split`](https://www.nushell.sh/commands/docs/split.html)，顾名思义，为我们提供了一种分割字符串的方法。我们将使用[`split`](https://www.nushell.sh/commands/docs/split.html)的`column`子命令，将内容分成多列。我们会告诉它分隔符是什么，剩下的就由它来完成：

```
> open people.txt | lines | split column "|"
───┬──────────┬───────────┬───────────
 # │ column1  │ column2   │ column3
───┼──────────┼───────────┼───────────
 0 │ Octavia  │  Butler   │  Writer
 1 │ Bob      │  Ross     │  Painter
 2 │ Antonio  │  Vivaldi  │  Composer
───┴──────────┴───────────┴───────────
```

这看起来差不多了，只是还有一些额外的空白字符，让我们 [`trim`](https://www.nushell.sh/commands/docs/str_trim.html) 掉这些空格：

```
> open people.txt | lines | split column "|" | str trim
───┬─────────┬─────────┬──────────
 # │ column1 │ column2 │ column3
───┼─────────┼─────────┼──────────
 0 │ Octavia │ Butler  │ Writer
 1 │ Bob     │ Ross    │ Painter
 2 │ Antonio │ Vivaldi │ Composer
───┴─────────┴─────────┴──────────
```

还不错，[`split`](https://www.nushell.sh/commands/docs/split.html)命令返回给我们可以使用的数据，还预设了默认的列名：

```
> open people.txt | lines | split column "|" | str trim | get column1
───┬─────────
 0 │ Octavia
 1 │ Bob
 2 │ Antonio
───┴─────────
```

我们也可以用自定义的列名代替默认的：

```
> open people.txt | lines | split column "|" first_name last_name job | str trim
───┬────────────┬───────────┬──────────
 # │ first_name │ last_name │ job
───┼────────────┼───────────┼──────────
 0 │ Octavia    │ Butler    │ Writer
 1 │ Bob        │ Ross      │ Painter
 2 │ Antonio    │ Vivaldi   │ Composer
───┴────────────┴───────────┴──────────
```

现在，我们的数据加载到一个表中了，我们可以使用之前对表所用的各种命令来处理它：

```
> open people.txt | lines | split column "|" first_name last_name job | str trim | sort-by first_name
───┬────────────┬───────────┬──────────
 # │ first_name │ last_name │ job
───┼────────────┼───────────┼──────────
 0 │ Antonio    │ Vivaldi   │ Composer
 1 │ Bob        │ Ross      │ Painter
 2 │ Octavia    │ Butler    │ Writer
───┴────────────┴───────────┴──────────
```

其他可用于字符串的命令有：

- `str`
- [`lines`](https://www.nushell.sh/commands/docs/lines.html)
- [`size`](https://www.nushell.sh/commands/docs/size.html)

如果我们已经知道待处理的数据具有 Nu 能够理解的格式，则可以使用一些辅助命令，例如，我们打开一个 Rust 的 Cargo.lock 文件：

```
> open Cargo.lock
# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
[[package]]
name = "adhoc_derive"
version = "0.1.2"
```

"Cargo.lock" 实际上是一个 .toml 文件，但是文件扩展名不是 .toml。没关系，我们可以使用 `from toml` 命令：

```
> open Cargo.lock | from toml
──────────┬───────────────────
 metadata │ [row 107 columns]
 package  │ [table 130 rows]
──────────┴───────────────────
```

每种 Nu 能打开并理解的结构化数据文本格式都有对应的 `from` 命令可以使用，只需要把支持的格式作为子命令传给 `from` 就可以了。

## [以原始模式打开](https://www.nushell.sh/zh-CN/book/loading_data.html#以原始模式打开)

虽然能够打开一个文件并立即使用其数据表很有帮助，但这并不总是我们想要的。为了获得原始文本，[`open`](https://www.nushell.sh/commands/docs/open.html)命令可以接受一个可选的`--raw`标志：

```
> open Cargo.toml --raw
[package]
name = "nu"
version = "0.1.3"
authors = ["Yehuda Katz <wycats@gmail.com>", "Sophia Turner <547158+sophiajt@users.noreply.github.com>"]
description = "A shell for the GitHub era"
license = "MIT"
```

## [获取 URLs](https://www.nushell.sh/zh-CN/book/loading_data.html#获取-urls)

除了从文件系统中加载文件，你还可以通过使用[`http get`](https://www.nushell.sh/commands/docs/fetch.html)命令来加载 URLs。这将从互联网上获取 URL 的内容并返回：

```
> http get https://blog.rust-lang.org/feed.xml
╭────────────┬──────────────────╮
│ tag        │ feed             │
│ attributes │ {record 1 field} │
│ content    │ [table 18 rows]  │
╰────────────┴──────────────────╯
```

# [处理字符串](https://www.nushell.sh/zh-CN/book/working_with_strings.html#处理字符串)

Nushell 中的字符串用于保存文本数据以便后续使用，其中可以包括文件名、文件路径、列名以及更多。字符串是如此地普遍，以至于 Nushell 提供了几种处理它们的方法，你可以从中选择最合适的。

## [单引号字符串](https://www.nushell.sh/zh-CN/book/working_with_strings.html#单引号字符串)

Nushell 中最简单的字符串是单引号字符串。这种字符串使用`'`字符来包裹文本。下面是作为单引号字符串的`hello world`示例：

```
> 'hello world'
hello world
```

单引号字符串不会对它们所给予的文本做任何事情，这使得它们成为容纳广泛文本数据的理想选择。

## [双引号字符串](https://www.nushell.sh/zh-CN/book/working_with_strings.html#双引号字符串)

对于更复杂的字符串，Nushell 也提供双引号字符串。这些字符串使用`"`字符来包裹文本。它们还支持使用`\`字符在文本中转义。

例如，我们可以用转义字符和双引号字符串写出文字 hello，然后换行，再写上 world：

```
> "hello\nworld"
hello
world
```

转义字符让你快速添加一个非此难以输入的字符。

Nushell 目前支持以下转义字符：

- `\"` - 双引号
- `\'` - 单引号
- `\\` - 反斜杠
- `\/` - 斜杠
- `\b` - 退格字符
- `\f` - 换页符
- `\r` - 回车符
- `\n` - 换行符 (line feed)
- `\t` - 制表符
- `\u{X...}` - Unicode 字符, 其中 X...为 1 到 6 位的十六进制数字

## [字符串插值](https://www.nushell.sh/zh-CN/book/working_with_strings.html#字符串插值)

更复杂的字符串用例还需要一种新的字符串形式：字符串插值。这是一种从原始文本和执行表达式的结果中构建文本的方法。字符串插值将这些结果结合在一起，返回一个新的字符串。

字符串插值使用 `$" "` 和 `$' '` 作为包裹插值文本的方式。

例如，假设我们有一个叫做`$name`的变量，我们想问候这个变量中所包含的人：

```
> let name = "Alice"
> $"greetings, ($name)"
greetings, Alice
```

通过使用`()`包裹表达式，我们可以运行它们并使用结果来帮助生成字符串。

字符串插值有单引号：`$' '` 和双引号：`$" "` 这两种形式，分别对应于单引号和双引号字符串 —— 单引号字符串插值不支持转义字符，而双引号字符串插值支持。

从 0.61 版开始，字符串插值支持转义小括号，所以`(`和`)`字符可以在一个字符串中使用，而 Nushell 不会试图计算它们之间出现的内容：

```
> $"2 + 2 is (2 + 2) \(you guessed it!)"
2 + 2 is 4 (you guessed it!)
```

## [分割字符串](https://www.nushell.sh/zh-CN/book/working_with_strings.html#分割字符串)

[`split row`](https://www.nushell.sh/commands/docs/split_row.html)命令从一个基于分隔符的字符串创建一个列表。 例如，`let colors = ("red,green,blue" | split row ",")` 创建列表`[red green blue]`。

[`split column`](https://www.nushell.sh/commands/docs/split_column.html)命令将从一个基于分隔符的字符串中创建一个表。例如，`let colors = ("red,green,blue" | split column ",")` 创建一个表格，并为每个元素添加一列。

最后, [`split chars`](https://www.nushell.sh/commands/docs/split_chars.html)命令将一个字符串分割成一个字符列表。

## [`str` 命令](https://www.nushell.sh/zh-CN/book/working_with_strings.html#str-命令)

许多字符串函数是`str`命令的子命令，你可以使用`help str`来获得一个完整的 `str` 命令列表。

例如, 你可以使用`str contains`来检查一个字符串是否包含某个特定的字符：

```
> "hello world" | str contains "w"
true
```

### [修剪字符串](https://www.nushell.sh/zh-CN/book/working_with_strings.html#修剪字符串)

你可以用 [`str trim`](https://www.nushell.sh/commands/docs/str_trim.html) 命令修剪字符串的两侧。默认情况下，[`str trim`](https://www.nushell.sh/commands/docs/str_trim.html) 命令会修剪字符串两边的空白。比如：

```
> '       My   string   ' | str trim
My   string
```

你可以用 `--right` 和 `--left` 选项来指定对哪一边进行修剪。

要修剪一个特定的字符，使用 `--char <Character>` 来指定要修剪的字符。

下面是一个传入了所有选项的例子：

```
> '=== Nu shell ===' | str trim -r -c '='
=== Nu shell
```

### [子字符串](https://www.nushell.sh/zh-CN/book/working_with_strings.html#子字符串)

子字符串是一个字符串的切片，它们有起始点和结束点。下面是一个使用子串的例子：

```
> 'Hello World!' | str index-of 'o'
4
> 'Hello World!' | str index-of 'r'
8
> 'Hello World!' | str substring 4..8
o Wo
```

### [字符串填充](https://www.nushell.sh/zh-CN/book/working_with_strings.html#字符串填充)

使用 [`str lpad`](https://www.nushell.sh/commands/docs/str_lpad.html) 和 [`str rpad`](https://www.nushell.sh/commands/docs/str_rpad.html) 命令，你可以给字符串添加填充。填充会给字符串添加字符，直到它达到一定的长度。比如：

```
> '1234' | str lpad -l 10 -c '0'
0000001234
> '1234' | str rpad -l 10 -c '0' | str length
10
```

### [反转字符串](https://www.nushell.sh/zh-CN/book/working_with_strings.html#反转字符串)

反转字符串可以通过 [`str reverse`](https://www.nushell.sh/commands/docs/str_reverse.html) 命令轻松完成：

```
> 'Nushell' | str reverse
llehsuN
> ['Nushell' 'is' 'cool'] | str reverse
╭───┬─────────╮
│ 0 │ llehsuN │
│ 1 │ si      │
│ 2 │ looc    │
╰───┴─────────╯
```

## [解析字符串](https://www.nushell.sh/zh-CN/book/working_with_strings.html#解析字符串)

通过 [`parse`](https://www.nushell.sh/commands/docs/parse.html) 命令，你可以将一个字符串解析成若干列。比如：

```
> 'Nushell is the best' | parse '{shell} is {type}'
╭───┬─────────┬──────────╮
│ # │  shell  │   type   │
├───┼─────────┼──────────┤
│ 0 │ Nushell │ the best │
╰───┴─────────┴──────────╯
> 'Bash is kinda cringe' | parse --regex '(?P<shell>\w+) is (?P<type>[\w\s]+)'
╭───┬───────┬──────────────╮
│ # │ shell │     type     │
├───┼───────┼──────────────┤
│ 0 │ Bash  │ kinda cringe │
╰───┴───────┴──────────────╯
```

## [字符串转换](https://www.nushell.sh/zh-CN/book/working_with_strings.html#字符串转换)

有多种方法可以将字符串转换为其他类型或者反之。

### [转换为字符串](https://www.nushell.sh/zh-CN/book/working_with_strings.html#转换为字符串)

1. 使用 [`into string`](https://www.nushell.sh/commands/docs/into_string.html)。例如：`123 | into string`
2. 通过字符串插值。例如：`$'(123)'`
3. 使用 [`build-string`](https://www.nushell.sh/commands/docs/build-string.html)。例如：`build-string (123)`

### [字符串转换为其他类型](https://www.nushell.sh/zh-CN/book/working_with_strings.html#字符串转换为其他类型)

1. 使用 [`into <type>`](https://www.nushell.sh/commands/docs/into.html)。例如：`'123' | into int`

## [字符串着色](https://www.nushell.sh/zh-CN/book/working_with_strings.html#字符串着色)

你可以通过 [`ansi`](https://www.nushell.sh/commands/docs/ansi.html) 命令给字符串着色。例如：

```
> $'(ansi purple_bold)This text is a bold purple!(ansi reset)'
```

`ansi purple_bold` 使文本紫色加粗

`ansi reset` 将着色重置为默认值。(提示: 你应该总是用 `ansi reset` 来结束着色的字符串)

# [处理表格](https://www.nushell.sh/zh-CN/book/working_with_tables.html#处理表格)

在 Nu 中查看数据的一种常见方式是通过表格。Nu 提供了许多处理表格的命令以方便找到你想要的内容以及将数据缩小到你需要的范围。

首先，让我们获得一个可用的表：

```
> ls
───┬───────────────┬──────┬─────────┬────────────
 # │ name          │ type │ size    │ modified
───┼───────────────┼──────┼─────────┼────────────
 0 │ files.rs      │ File │  4.6 KB │ 5 days ago
 1 │ lib.rs        │ File │   330 B │ 5 days ago
 2 │ lite_parse.rs │ File │  6.3 KB │ 5 days ago
 3 │ parse.rs      │ File │ 49.8 KB │ 1 day ago
 4 │ path.rs       │ File │  2.1 KB │ 5 days ago
 5 │ shapes.rs     │ File │  4.7 KB │ 5 days ago
 6 │ signature.rs  │ File │  1.2 KB │ 5 days ago
───┴───────────────┴──────┴─────────┴────────────
```

## [排序](https://www.nushell.sh/zh-CN/book/working_with_tables.html#排序)

我们可以通过调用[`sort-by`](https://www.nushell.sh/commands/docs/sort-by.html)命令对一个表进行排序，并指定需要排序的列。比如，按照文件的大小对表格进行排序：

```
> ls | sort-by size
───┬───────────────┬──────┬─────────┬────────────
 # │ name          │ type │ size    │ modified
───┼───────────────┼──────┼─────────┼────────────
 0 │ lib.rs        │ File │   330 B │ 5 days ago
 1 │ signature.rs  │ File │  1.2 KB │ 5 days ago
 2 │ path.rs       │ File │  2.1 KB │ 5 days ago
 3 │ files.rs      │ File │  4.6 KB │ 5 days ago
 4 │ shapes.rs     │ File │  4.7 KB │ 5 days ago
 5 │ lite_parse.rs │ File │  6.3 KB │ 5 days ago
 6 │ parse.rs      │ File │ 49.8 KB │ 1 day ago
───┴───────────────┴──────┴─────────┴────────────
```

我们可以通过任何可以比较的列来对一个表进行排序。例如，我们也可以用 "name", "accessed" 或者 "modified" 列对上述内容进行排序。

## [选取](https://www.nushell.sh/zh-CN/book/working_with_tables.html#选取)

我们可以从表中通过选择特定的列或行来获得数据。让我们从表中选择（[`select`](https://www.nushell.sh/commands/docs/select.html)）几列吧：

```
> ls | select name size
───┬───────────────┬─────────
 # │ name          │ size
───┼───────────────┼─────────
 0 │ files.rs      │  4.6 KB
 1 │ lib.rs        │   330 B
 2 │ lite_parse.rs │  6.3 KB
 3 │ parse.rs      │ 49.8 KB
 4 │ path.rs       │  2.1 KB
 5 │ shapes.rs     │  4.7 KB
 6 │ signature.rs  │  1.2 KB
───┴───────────────┴─────────
```

这有助于创建一个更专注于我们所需的表格。接下来，假设我们只想看这个目录中最小的 5 个文件：

```
> ls | sort-by size | first 5
───┬──────────────┬──────┬────────┬────────────
 # │ name         │ type │ size   │ modified
───┼──────────────┼──────┼────────┼────────────
 0 │ lib.rs       │ File │  330 B │ 5 days ago
 1 │ signature.rs │ File │ 1.2 KB │ 5 days ago
 2 │ path.rs      │ File │ 2.1 KB │ 5 days ago
 3 │ files.rs     │ File │ 4.6 KB │ 5 days ago
 4 │ shapes.rs    │ File │ 4.7 KB │ 5 days ago
───┴──────────────┴──────┴────────┴────────────
```

你会注意到我们首先按大小对表进行排序以得到最小的文件，然后我们用`first 5`来返回表的前 5 行。

你也可以跳过(`skip`)不需要的行，让我们跳过上面所得 5 行中的前两行：

```
> ls | sort-by size | first 5 | skip 2
───┬───────────┬──────┬────────┬────────────
 # │ name      │ type │ size   │ modified
───┼───────────┼──────┼────────┼────────────
 0 │ path.rs   │ File │ 2.1 KB │ 5 days ago
 1 │ files.rs  │ File │ 4.6 KB │ 5 days ago
 2 │ shapes.rs │ File │ 4.7 KB │ 5 days ago
───┴───────────┴──────┴────────┴────────────
```

我们已将其缩小为我们关心的三行。

让我们看看其他几个用于选择数据的命令。您可能想知道为什么选取表格的行是通过数字，这是选择单行数据的便捷方式。让我们按文件名对表进行排序，然后使用 `select` 命令通过行号来选择其中的一行：

```
> ls | sort-by name
───┬───────────────┬──────┬─────────┬────────────
 # │ name          │ type │ size    │ modified
───┼───────────────┼──────┼─────────┼────────────
 0 │ files.rs      │ File │  4.6 KB │ 5 days ago
 1 │ lib.rs        │ File │   330 B │ 5 days ago
 2 │ lite_parse.rs │ File │  6.3 KB │ 5 days ago
 3 │ parse.rs      │ File │ 49.8 KB │ 1 day ago
 4 │ path.rs       │ File │  2.1 KB │ 5 days ago
 5 │ shapes.rs     │ File │  4.7 KB │ 5 days ago
 6 │ signature.rs  │ File │  1.2 KB │ 5 days ago
───┴───────────────┴──────┴─────────┴────────────

> ls | sort-by name | select 5
───┬───────────────┬──────┬─────────┬────────────
 # │ name          │ type │ size    │ modified
───┼───────────────┼──────┼─────────┼────────────
 0 │ shapes.rs     │ File │  4.7 KB │ 5 days ago
───┴───────────────┴──────┴─────────┴────────────
```

## [从表格提取数据](https://www.nushell.sh/zh-CN/book/working_with_tables.html#从表格提取数据)

到目前为止，我们在处理表格时都是将表格修剪成我们需要的样子。有时我们可能想更进一步，只看单元格本身的值，而不是取整列。比如，我们只想得到一个包含所有文件名的列表。在此，我们使用[`get`](https://www.nushell.sh/commands/docs/get.html) 命令：

```
> ls | get name
───┬───────────────
 0 │ files.rs
 1 │ lib.rs
 2 │ lite_parse.rs
 3 │ parse.rs
 4 │ path.rs
 5 │ shapes.rs
 6 │ signature.rs
───┴───────────────
```

现在我们获得了每一个文件的文件名。

这可能看起来很像我们之前使用的[`select`](https://www.nushell.sh/commands/docs/select.html)命令，所以也把它放在这里以便于比较：

```
> ls | select name
───┬───────────────
 # │ name
───┼───────────────
 0 │ files.rs
 1 │ lib.rs
 2 │ lite_parse.rs
 3 │ parse.rs
 4 │ path.rs
 5 │ shapes.rs
 6 │ signature.rs
───┴───────────────
```

这看起来非常相似！让我们看看能不能把这两个命令的区别说清楚：

- [`select`](https://www.nushell.sh/commands/docs/select.html) - 创建一个只包括指定列的新表；
- [`get`](https://www.nushell.sh/commands/docs/get.html) - 以列表形式返回指定列内的值；

区分这些表格的方法是 —— 列名没有了，也让我们知道这是一个我们可以处理的值的列表。

[`get`](https://www.nushell.sh/commands/docs/get.html)命令可以更进一步，它可以接受表中更深的数据路径。这简化了对复杂数据的处理，比如那些你可能在.json 文件中发现的结构。

## [修改表格数据](https://www.nushell.sh/zh-CN/book/working_with_tables.html#修改表格数据)

除了从表中选择数据外，还可以更新其中的数据。我们可能想合并表格，添加新的列，或编辑单元格的内容等。在 Nushell 中，本节中的每个命令都会在管道中返回一个新的表而非对原表进行编辑。

### [拼接表格](https://www.nushell.sh/zh-CN/book/working_with_tables.html#拼接表格)

我们可以使用[`append`](https://www.nushell.sh/commands/docs/append.html)将列名相同的表拼接起来：

```
> let $first = [[a b]; [1 2]]
> let $second = [[a b]; [3 4]]
> $first | append $second
───┬───┬───
 # │ a │ b
───┼───┼───
 0 │ 1 │ 2
 1 │ 3 │ 4
───┴───┴───
```

### [合并表格](https://www.nushell.sh/zh-CN/book/working_with_tables.html#合并表格)

我们可以使用[`merge`](https://www.nushell.sh/commands/docs/merge.html)命令将两个（或多个）表格合并在一起：

```
> let $first = [[a b]; [1 2]]
> let $second = [[c d]; [3 4]]
> $first | merge { $second }
───┬───┬───┬───┬───
 # │ a │ b │ c │ d
───┼───┼───┼───┼───
 0 │ 1 │ 2 │ 3 │ 4
───┴───┴───┴───┴───
```

让我们再加一个表格吧：

```
> let $third = [[e f]; [5 6]]
```

我们可以将以上三个表格合并在一起，操作如下：

```
> $first | merge { $second } | merge { $third }
───┬───┬───┬───┬───┬───┬───
 # │ a │ b │ c │ d │ e │ f
───┼───┼───┼───┼───┼───┼───
 0 │ 1 │ 2 │ 3 │ 4 │ 5 │ 6
───┴───┴───┴───┴───┴───┴───
```

或者我们可以使用[`reduce`](https://www.nushell.sh/commands/docs/reduce.html)命令来动态地合并所有的表格：

```
> [$first $second $third] | reduce {|it, acc| $acc | merge { $it }}
───┬───┬───┬───┬───┬───┬───
 # │ a │ b │ c │ d │ e │ f
───┼───┼───┼───┼───┼───┼───
 0 │ 1 │ 2 │ 3 │ 4 │ 5 │ 6
───┴───┴───┴───┴───┴───┴───
```

### [添加新列](https://www.nushell.sh/zh-CN/book/working_with_tables.html#添加新列)

我们可以使用[`insert`](https://www.nushell.sh/commands/docs/insert.html)命令在表中增加新列，让我们看一个例子：

```
> open rustfmt.toml
─────────┬──────
 edition │ 2018
─────────┴──────
```

让我们添加一个名为 "next_edition" 的列并将 2021 作为值：

```
> open rustfmt.toml | insert next_edition 2021
──────────────┬──────
 edition      │ 2018
 next_edition │ 2021
──────────────┴──────
```

注意，我们如果打开原始文件，会发现内容没变：

```
> open rustfmt.toml
─────────┬──────
 edition │ 2018
─────────┴──────
```

Nu 的更改是函数性更改，这意味着它们只在值上起作用，而不是试图引起永久性变更。这使我们可以在管道中进行许多不同类型的操作直到我们准备好将结果输出(如果我们选择这样做的话)。这里我们可以使用 [`save`](https://www.nushell.sh/commands/docs/save.html) 命令保存结果：

```
> open rustfmt.toml | insert next_edition 2021 | save rustfmt2.toml
> open rustfmt2.toml
──────────────┬──────
 edition      │ 2018
 next_edition │ 2021
──────────────┴──────
```

### [更新一列](https://www.nushell.sh/zh-CN/book/working_with_tables.html#更新一列)

与[`insert`](https://www.nushell.sh/commands/docs/insert.html)命令类似，我们也可以使用[`update`](https://www.nushell.sh/commands/docs/update.html)命令将某一列的内容修改为新值。为了看看效果，让我们打开同一个文件：

```
> open rustfmt.toml
─────────┬──────
 edition │ 2018
─────────┴──────
```

现在，用我们希望支持的下一个版本更新 edition：

```
> open rustfmt.toml | update edition 2021
─────────┬──────
 edition │ 2021
─────────┴──────
```

你也可以使用[`upsert`](https://www.nushell.sh/commands/docs/upsert.html)命令来插入或更新，这取决于该列是否已经存在。

### [移动列](https://www.nushell.sh/zh-CN/book/working_with_tables.html#移动列)

你可以使用`move`来移动表中的列。例如，如果想把`ls`中的 "name" 列移到 "size" 列之后，我们可以这样做：

```
> ls | move name --after size
╭────┬──────┬─────────┬───────────────────┬──────────────╮
│ #  │ type │  size   │       name        │   modified   │
├────┼──────┼─────────┼───────────────────┼──────────────┤
│  0 │ dir  │   256 B │ Applications      │ 3 days ago   │
│  1 │ dir  │   256 B │ Data              │ 2 weeks ago  │
│  2 │ dir  │   448 B │ Desktop           │ 2 hours ago  │
│  3 │ dir  │   192 B │ Disks             │ a week ago   │
│  4 │ dir  │   416 B │ Documents         │ 4 days ago   │
...
```

### [重命名列](https://www.nushell.sh/zh-CN/book/working_with_tables.html#重命名列)

你也可以通过`rename`命令对表中的列进行**重命名**。我们可以使用这个例子来运行`ls`并重命名这些列：

```
> ls | rename filename filetype filesize date
╭────┬───────────────────┬──────────┬──────────┬──────────────╮
│ #  │     filename      │ filetype │ filesize │     date     │
├────┼───────────────────┼──────────┼──────────┼──────────────┤
│  0 │ Applications      │ dir      │    256 B │ 3 days ago   │
│  1 │ Data              │ dir      │    256 B │ 2 weeks ago  │
│  2 │ Desktop           │ dir      │    448 B │ 2 hours ago  │
│  3 │ Disks             │ dir      │    192 B │ a week ago   │
│  4 │ Documents         │ dir      │    416 B │ 4 days ago   │
...
```
