# 用例图，说明，及实现思路

![[截圖 2024-09-06 16.16.05.png]]


## 用例说明：

### 1. 库存管理

- **用例名称**：库存管理
- **用例描述**：该用例描述了仓库管理员和仓库工作人员如何使用仓库管理系统进行库存的添加、减少、查询及调整，以保持库存的准确性和及时性。
- **参与者**：
  - **主参与者**：仓库管理员
  - **次要参与者**：仓库工作人员
- **前置条件**：
  - 用户已登录系统并具有管理库存的权限。
  - 库存管理模块正常运行，数据库处于可访问状态。
- **后置条件**：
  - 库存记录已成功更新。
  - 相关库存报表自动生成，系统中库存数据保持同步。
- **主事件流程**：
  1. 仓库管理员或工作人员登录仓库管理系统。
  2. 选择“库存管理”模块，进入库存操作界面。
  3. 在界面中选择以下操作之一：
     - **添加库存**：选择入库选项，输入商品信息（商品名称、数量、入库时间、供应商信息等），提交后系统自动更新库存记录。
     - **减少库存**：选择出库选项，输入需要出库的商品信息和数量，确认后系统自动减少库存。
     - **查询库存**：输入商品编号或名称，系统显示该商品的库存状态，包括当前库存量、入库日期、批次等信息。
     - **调整库存**：对由于盘点或损坏等原因需调整的库存，仓库管理员输入商品信息和调整原因，系统保存调整记录。
  4. 系统自动更新数据库中的库存信息。
  5. 库存变化后，系统生成并显示库存报表，包括所有涉及的商品、操作类型和库存数量变更。
  6. 操作完成，用户退出系统。
- **扩展事件流程**：
  - **库存不足时的处理**：当用户选择减少库存，但系统检测到库存不足时，系统会提示库存不足，并建议联系采购部门进行补货。
  - **错误数据处理**：当输入的商品信息与系统中的记录不符时，系统会提示检查数据，并允许重新输入或联系管理员处理。
  - **自动盘点提醒**：系统定期自动提醒仓库管理员进行库存盘点，并在库存出现异常时发出警报。

### 备注：
- **相关用例**：入库处理、出库处理、库存盘点
- **数据接口**：该用例依赖库存数据库，并且与订单处理系统和财务系统共享数据


### 2. 订单管理

- **用例名称**：订单管理
- **用例描述**：该用例描述了仓库管理员如何通过系统管理客户订单，从订单的接收、处理到发货，确保订单的准确履行。
- **参与者**：
  - **主参与者**：仓库管理员
  - **次要参与者**：仓库工作人员，客户
- **前置条件**：
  - 用户已登录系统并具有订单管理权限。
  - 系统内已有库存信息，并且商品状态正常可用。
- **后置条件**：
  - 订单状态已更新为“已发货”。
  - 系统生成出库记录，并更新库存信息。
- **主事件流程**：
  1. 仓库管理员登录仓库管理系统。
  2. 选择“订单管理”模块，进入订单处理界面。
  3. 查看客户提交的订单，包括商品名称、数量、客户信息等详细信息。
  4. 仓库管理员对订单进行处理：
     - **审核订单**：确认订单商品是否有足够的库存，若库存充足，进入下一步；否则提示库存不足并通知采购部门。
  5. 审核通过后，系统自动生成出库单，仓库工作人员根据出库单准备发货。
  6. 仓库工作人员扫描商品条码，系统核对商品数量并更新库存。
  7. 商品准备完成后，仓库管理员确认发货并更新订单状态为“已发货”。
  8. 系统自动生成订单发货记录，通知客户发货成功，并生成出库凭证。
  9. 订单管理完成，仓库管理员可退出系统。
  
- **扩展事件流程**：
  - **库存不足时的处理**：当库存不足时，系统自动提示库存不足，允许仓库管理员联系采购部门补货，或取消订单，并通知客户。
  - **部分发货**：如果订单中的某些商品库存不足，系统允许部分发货，并将未发货部分记录为“待发货”状态，待库存补充后再完成发货。
  - **订单取消**：客户在订单处理中取消订单，系统将订单状态更新为“已取消”，并通知相关部门。
  - **异常发货处理**：发货过程中如果发生商品数量不匹配，系统将提示仓库管理员重新核对商品信息或重新生成出库单。

### 备注：
- **相关用例**：库存管理、出库管理、客户管理
- **数据接口**：该用例依赖订单数据库和库存数据库，并与财务系统共享数据，确保订单和库存信息的同步更新

### 3. 报表生成

• **用例名称**：报表生成
• **用例描述**：该用例描述了仓库管理员如何通过系统生成库存、订单、出入库等报表，帮助管理层或其他相关人员了解仓库运营情况。
• **参与者**：
• **主参与者**：仓库管理员
• **次要参与者**：管理层、财务人员
• **前置条件**：
• 用户已登录系统并具有生成报表的权限。
• 系统内已有相关数据（库存、订单、出入库记录等）。
• **后置条件**：
• 系统生成指定的报表，并可供用户导出或打印。
• **主事件流程**：
1. 仓库管理员登录仓库管理系统。
2. 选择“报表生成”模块，进入报表生成界面。
3. 在界面中选择报表类型，常见报表包括：
• **库存报表**：当前所有商品的库存情况，包括数量、位置、入库时间等。
• **订单报表**：所有订单的处理情况，包括订单编号、客户信息、订单状态（已发货、待发货）等。
• **出入库报表**：一段时间内的商品出库和入库情况，记录详细的商品信息、操作人员、时间等。
• **盘点报表**：定期或临时库存盘点的结果，包括盘点前后库存差异、盘点原因等。
• **财务报表**：相关的财务数据，包括库存价值、订单金额等。
4. 输入报表的筛选条件（如时间范围、商品类别、订单状态等），并确认生成报表。
5. 系统自动从数据库中检索相关数据，并生成所选报表。
6. 系统显示生成的报表，用户可以选择预览、导出（如 Excel、PDF 格式）或打印报表。
7. 仓库管理员确认报表准确性，保存并完成报表生成。
• **扩展事件流程**：
• **数据异常处理**：如果在生成报表过程中数据不完整或出现异常，系统将提示用户检查数据来源，或重新生成报表。
• **自定义报表**：允许用户自定义报表内容和格式，如根据特殊需求添加额外字段或修改报表模板。
• **自动定期生成**：系统支持设置定期生成报表功能，管理员可以配置报表的生成频率（如每周、每月），系统到时间自动生成并发送至指定人员的邮箱。
• **历史报表查询**：系统保存已生成的历史报表，用户可以随时查询和下载。 

**备注：**
  
• **相关用例**：库存管理、订单管理、出入库管理
• **数据接口**：该用例依赖系统中的库存数据库、订单数据库、出入库记录等数据源，并与财务系统共享报表数据，确保报表数据的准确性和实时性

### 4. 系统配置

• **用例名称**：系统配置
• **用例描述**：该用例描述了系统管理员如何通过系统管理用户权限、角色设置、系统参数以及其他基础配置，确保仓库管理系统的安全性和可操作性。
• **参与者**：
• **主参与者**：系统管理员
• **次要参与者**：仓库管理员，IT支持人员
• **前置条件**：
• 系统管理员已登录系统并具有配置系统的权限。
• 系统正常运行，相关配置模块已启用。
• **后置条件**：
• 系统配置已保存，系统功能按配置执行。
• 相关用户角色和权限已更新，系统参数已生效。
• **主事件流程**：
1. 系统管理员登录仓库管理系统。
2. 选择“系统配置”模块，进入系统配置管理界面。
3. 系统管理员可以选择进行以下配置操作：
• **用户管理**：添加、删除或修改系统用户账户，设置每个用户的基本信息（用户名、密码等）。
• **权限管理**：分配用户角色（如仓库管理员、仓库工作人员、财务人员），并根据角色设定用户权限（如库存管理权限、订单管理权限等）。
• **系统参数配置**：修改系统的全局参数，如库存警戒线、自动报表生成频率、默认出入库处理方式等。
• **通知设置**：配置库存、订单异常的自动通知方式（如邮件、短信），设置系统消息提醒。
• **日志管理**：查看和管理系统操作日志，监控系统的运行状态，记录用户操作以便追踪问题。
4. 系统管理员根据业务需求，完成所需的配置操作。
5. 配置完成后，系统管理员保存配置，系统自动更新相关参数，并提示配置成功。
6. 系统管理员可以选择退出系统配置模块，其他用户根据新的配置使用系统。
• **扩展事件流程**：
• **用户权限冲突处理**：如果管理员在配置权限时分配了冲突权限（如普通用户被分配了系统管理员权限），系统将提示错误并要求重新分配。
• **系统参数恢复默认**：如果系统管理员设置的参数影响了系统运行，可以选择恢复默认配置，系统将提示确认操作并进行恢复。
• **异常配置提示**：如果配置项输入不合法（如设置了超出合理范围的库存警戒线），系统将提示用户并阻止保存操作。
• **多角色权限管理**：系统支持用户拥有多个角色，管理员可以为用户分配多个权限，系统自动合并权限。
  
**备注：**

• **相关用例**：用户管理、权限管理、通知管理、日志管理
• **数据接口**：该用例与系统用户数据库、权限管理模块和日志管理模块交互，确保系统配置的同步更新和执行

### 业务用例

### 1. 检索货物出入库请求和记录

• **业务用例名称**：检索货物出入库请求和记录
• **业务目标**：为物流系统提供准确的货物出入库信息，支持货物运输和跟踪，确保物流流程的顺畅进行。
• **前提条件**：
• 物流系统已与仓库管理系统对接，且具有查询权限。
• 仓库管理系统中已有货物的出入库记录和请求。
• **主要参与者**：
• **物流系统**：负责检索仓库系统中的出入库信息，以便货物运输和追踪。
• **仓库管理系统**：存储并提供货物的出入库记录和请求。
• **物流操作人员**：通过物流系统检索货物信息，以安排运输或确认状态。

**主要事件流程：**

1. 物流操作人员登录物流系统。
2. 物流操作人员在物流系统中选择“查询出入库记录”模块，进入查询界面。
3. 物流系统向仓库管理系统发送查询请求，包含以下检索条件之一或组合：
• 货物编号
• 出入库单号
• 出入库时间范围
• 目的地/来源地
• 操作类型（入库/出库）
4. 仓库管理系统接收到查询请求，检索相应的货物出入库记录。
5. 仓库管理系统将符合条件的出入库记录发送回物流系统，包括以下信息：
• 货物的出入库时间
• 出库/入库数量
• 操作人
• 货物当前状态（已发货/待发货/已入库）
• 目的地/来源地
• 出入库单号
6. 物流系统显示查询结果，物流操作人员根据结果安排相应的物流操作。
7. 操作完成后，物流操作人员确认并保存查询记录，系统操作流程结束。

**扩展流程：**

• **无匹配记录处理**：如果物流系统未检索到相关的出入库记录，系统会提示“无符合条件的记录”，并建议用户检查查询条件或重新输入。
• **部分匹配处理**：如果查询结果显示部分货物的出入库记录（例如部分货物仍在处理中），系统将标记未完成的货物状态，并建议后续跟踪。
• **异常处理**：如果仓库管理系统无法提供出入库记录（如数据库连接失败或权限不足），物流系统将提示查询失败，并要求管理员检查系统状态。
• **批量查询**：物流系统支持批量查询功能，操作人员可以一次性检索多个货物的出入库记录，系统按货物编号分别返回结果。

**业务规则：**
  
• 物流系统只能检索其权限范围内的货物信息，不能访问其他未授权的仓库或货物记录。

• 出入库记录需要保持实时更新，确保物流系统获取的信息是最新的。

**备注：**


• **相关系统**：仓库管理系统、物流系统
• **数据接口**：物流系统通过API或数据库访问仓库管理系统，获取货物的出入库记录和请求数据，确保信息的实时准确性

### 2. 检索货物并提交价格修改申请

• **业务用例名称**：供应商检索货物并提交价格修改申请
• **业务目标**：为供应商提供货物信息查询功能，并允许其提交价格修改申请，确保供应链价格调整的透明性和及时性。
• **前提条件**：
• 供应商已登录系统并具备相应的权限。
• 系统中已有供应商相关的货物信息。
• 供应商具备修改货物价格的权限，并且系统允许此类操作。
• **主要参与者**：
• **供应商**：负责检索相关货物信息并提交价格修改申请。
• **仓库管理系统**：存储供应商相关的货物信息，处理供应商的价格修改申请。
• **采购部门**：审核和批准供应商提交的价格修改申请。
  
**主要事件流程：**

1. 供应商登录系统，进入“货物管理”模块。
2. 供应商在界面中选择“检索货物”功能，输入检索条件，如：
• 货物编号
• 商品名称
• 货物分类
• 供应商编号
3. 系统根据供应商提供的条件检索相应的货物信息，并返回查询结果，包括以下信息：
• 货物名称
• 当前库存
• 货物当前价格
• 商品编号
• 供应商信息
4. 供应商浏览查询结果，选择需要修改价格的货物，进入“价格修改申请”界面。
5. 供应商在界面中填写价格修改申请表，输入新的价格和修改原因，确认提交。
6. 系统接收到申请后，自动将价格修改申请发送至采购部门进行审核。
7. 采购部门审核申请，根据业务需求决定是否批准价格修改。
8. 如果申请通过，系统自动更新相关货物的价格记录，并通知供应商。
9. 如果申请未通过，系统会通知供应商拒绝原因，并允许供应商重新提交或取消申请。
  

**扩展流程：**

• **价格修改审批拒绝**：如果采购部门拒绝价格修改申请，系统将通知供应商拒绝原因，供应商可以根据反馈信息调整价格或联系采购部门协商。
• **价格修改审批超时**：如果采购部门未在规定时间内处理价格修改申请，系统将自动提醒相关人员进行处理，或允许供应商撤销申请。
• **多批次价格修改**：系统支持供应商对多个货物的价格批量修改，供应商可同时提交多个货物的价格修改申请，系统依次处理。
• **无货物匹配**：如果系统未能检索到与供应商相关的货物，系统将提示“无符合条件的货物”，供应商可以调整查询条件或联系管理员处理。

**业务规则：**

• 供应商只能检索和修改与自己相关的货物价格，不能访问其他供应商的商品信息。
• 价格修改申请必须提供合理的修改原因，系统将存储每次价格变动的记录以便后续审计。
• 采购部门有最终的价格修改批准权，系统只会在申请通过后生效。

**备注：**
  
• **相关系统**：仓库管理系统、供应商管理系统、采购部门审批系统
• **数据接口**：供应商通过API或系统界面与仓库管理系统交互，检索货物信息并提交价格修改申请

### 3. 客户检索货物存量及单价信息
• **业务用例名称**：客户检索货物存量及单价信息
• **业务目标**：为客户提供查询货物库存和单价信息的功能，帮助客户进行采购决策或库存监控。
• **前提条件**：
• 客户已登录系统并具有查询权限。
• 仓库管理系统已录入货物的存量和单价信息，并已对外开放查询接口。
• **主要参与者**：
• **客户**：负责查询货物的库存和单价，以便进行采购决策或库存监控。
• **仓库管理系统**：提供货物的库存数量和单价信息。
  
**主要事件流程：**

1. 客户登录仓库管理系统。
2. 客户选择“查询货物信息”模块，进入查询界面。
3. 客户输入检索条件进行货物查询，常见的检索条件包括：

• 货物编号
• 商品名称
• 商品分类
• 价格范围
• 库存状态（有货/缺货）
4. 系统根据客户提供的条件检索相关的货物信息，并返回查询结果，包括以下信息：
• 货物名称
• 当前库存数量
• 货物单价
• 商品编号
• 库存状态（是否有货）
5. 客户浏览查询结果，并根据货物的存量和单价信息决定下一步操作（如下单采购或继续监控库存）。
6. 客户可以选择导出查询结果，或保存查询记录以便后续参考。
7. 查询结束，客户退出系统或继续进行其他操作。
  
**扩展流程：**

• **无货物匹配**：如果系统未能检索到符合条件的货物，系统将提示“无符合条件的货物”，客户可以调整检索条件重新查询。
• **货物缺货处理**：如果查询结果显示货物缺货，系统将提示客户该货物的预计补货时间或允许客户预定货物。
• **库存实时更新**：系统确保客户查询的库存信息为实时更新的，以便客户获取最新的库存状态和单价信息。
• **批量查询**：客户可以通过系统批量查询多个货物的信息，系统将同时返回多个货物的存量和单价。

**业务规则：**

• 客户只能查看与其相关的货物存量和单价信息，不能查看其他客户或未授权货物的信息。
• 系统根据客户的查询条件精准匹配库存数据，保证信息的准确性和及时性。
• 客户查询结果中的单价为系统当前的标记价格，任何价格波动或变更会通过系统通知客户。


**备注：**

• **相关系统**：仓库管理系统、客户管理系统
• **数据接口**：客户通过系统与仓库管理系统交互，获取货物的库存数量、单价等相关信息，支持实时查询和数据导出

## 特性需求
### 安全性
安全性需要后端基础设施完备且前后端配合,并且合理部署
详细说明见后端重点

### 易于部署
目标是通过单一二进制文件在任何主流平台简单完成部署.包括嵌入式数据库,数据迁移,管理员用户生成等初始化流程自动化完成,通过环境变量方便配置,单一指令快速启动

### 跨平台
在开发中我主要使用linux环境,x86-64架构,但通过在不同平台和架构的构建来实现跨平台和多架构的兼容.这也使得程序的各个部分集成程度很高

## 应用程序架构

- 前端使用React jsx
- 后端使用Rust
- 采用嵌入式数据库,Diesel 与 SQLite 结合
- 由Rust提供静态文件服务,使得前后端分离设计但是部署时统一
- web框架由Rocket提供
- 去中心化的仓库管理系统,各个仓库节点独立运行并相互协作

## 功能需求

- 入库
- 出库
- 货品查询(多仓库联动)
- 货品分类
- 多管理员
- 不同仓库间货品调度(通过不同服务端联动实现,一个服务对应一个仓库)

# 后端

## 依赖

```toml
[package]

name = "app1"

version = "0.1.0"

edition = "2021"

  

[dependencies]
# 用于数据库的对象关系映射

diesel = { version = "^2.1", features = ["sqlite", "r2d2", "chrono"] }
# 用于初始化环境变量

dotenvy = "^0.15"

# 用于将数据结构序列化和反序列化
serde = { version = "^1.0", features = ["derive"] }
# 用于数据结构序列化和反序列化为json
serde_json = "^1.0"

# 处理时间格式的库
chrono = { version = "^0.4", features = ["serde"] }
# web框架
rocket = { version = "^0.5", features = ["json"] }
# 用于为web服务附加数据库连接池
rocket_sync_db_pools = { version = "^0.1", features = ["diesel_sqlite_pool"] }

# 用于web框架处理跨域资源访问
rocket_cors = "0.6.0"

  

# rusqlite = "^0.31"
# 用于生产随机字符串
rand = "^0.8"
# 用于构建数据库
libsqlite3-sys = { version = "^0.28", features = ["bundled"] }

  
# 用于对函数进行同步或异步处理
async-std = "^1"

# 用于异步I/O和跨进程通信的抽象
futures = "^0.3"

# 用于生成uuid
uuid = { version = "1", features = ["v4"] }


  
# 用于构建p2p网络
libp2p = "0.46.1"

# 用于提供异步运行时
tokio = { version = "1.19.2", features = ["full"] }

tokio-util = { version = "0.7.11", features = ["compat", "io"] }

# 日志记录器
env_logger = "^0.11"

log = "^0.4"

log4rs = "^1.3"

# 提供数据结构序列化与反序列化的yaml支持

serde_yaml = "0.9.34+deprecated"

# 提供为路由使用jwt的相关支持 

jsonwebtoken = "^9.3.0"


# 用于对Trait提供异步支持
async-trait = "0.1.80"

# 用于base64编码
base64 = "0.22.1"

  
# web框架相关依赖  

[dependencies.rocket_dyn_templates]

version = "^0.2"

features = ["handlebars"]

  

[dependencies.rocket_contrib]

version = "^0.4"

features = ["json"]

  

[dependencies.diesel_migrations]

version = "^2.2"
```

> 截止至目前(24.5.26)依赖更新情况,以[crates.io](https://crates.io)为参考

| 依赖                                                                    | 版本       |
| --------------------------------------------------------------------- | -------- |
| [diesel](https://crates.io/crates/diesel)                             | v2.1.6   |
| [dotenvy](https://crates.io/crates/dotenvy)                           | v0.15.7  |
| [serde](https://crates.io/crates/serde)                               | v1.0.203 |
| [serde_json](https://crates.io/crates/serde_json)                     | v1.0.117 |
| [chrono](https://crates.io/crates/chrono)                             | v0.4.38  |
| [rocket](https://crates.io/crates/rocket)                             | v0.5.1   |
| [rocket_sync_db_pools](https://crates.io/crates/rocket_sync_db_pools) | v0.1.0   |
| [rand](https://crates.io/crates/rand)                                 | v0.8.5   |
| [libsqlite3-sys](https://crates.io/crates/libsqlite3-sys)             | v0.28.0  |
| [log](https://crates.io/crates/log)                                   | v0.4.21  |
| [env_logger](https://crates.io/crates/env_logger)                     | v0.11.3  |
| [rocket_dyn_templates](https://crates.io/crates/rocket_dyn_templates) | v0.2.0   |
| [rocket_contrib](https://crates.io/crates/rocket_contrib)             | v0.4.11  |
| [diesel_migrations](https://crates.io/crates/diesel_migrations)       | v2.2.0   |
*[依赖介绍](依赖)* 

## 在Rust项目中使用Diesel来管理这些表和数据操作

## 后端实现

### 后端重点

重点应放在建立完备的访问安全性基础设施和完备合理的错误处理上.


### 网络访问的安全性

1. **P2P 通信加密和数字签名**：
   - **加密**：确保 P2P 通信使用强加密算法（如 AES、RSA）来保护数据的机密性。
   - **数字签名**：使用数字签名来验证消息的完整性和来源，确保数据未被篡改并且来自可信源。

2. **HTTP 接口和跨域资源访问**：
   - **CORS 配置**：在前端代理配置 CORS（跨域资源共享）规则时，确保只允许受信任的域名进行访问。
   - **安全头部**：配置 HTTP 安全头部，如 `Content-Security-Policy` 和 `Strict-Transport-Security`，进一步提升安全性。

3. **HTTPS 加密**：
   - **证书管理**：使用有效的 SSL/TLS 证书并定期更新，确保 HTTPS 加密的安全性。
   - **反向代理**：配置反向代理（如 Nginx、Apache）处理 HTTPS 加密，保护所有前端和后端通信。

4. **Cookie 安全性**：
   - **密钥加密**：使用强加密算法保护 cookie 数据。
   - **HttpOnly**：启用 `HttpOnly` 标志以防止客户端脚本访问 cookie，减少 XSS 攻击的风险。
   - **Secure**：设置 `Secure` 标志以确保 cookie 仅通过 HTTPS 传输。

### 仓库管理系统的实际应用情况

1. **超级管理员行为限制**：
   - **权限管理**：实施细粒度权限控制，限制超级管理员的操作范围，防止误操作或恶意行为。
   - **记录标记**：使用标记（如软删除）而不是完全删除记录，确保历史记录的可追溯性和恢复能力。

2. **消息队列和日志记录**：
   - **消息队列**：使用可靠的消息队列系统（如 RabbitMQ、Kafka）来处理数据库读写请求，确保请求的顺序和完整性。
   - **日志记录**：实施日志记录策略，记录所有重要操作和事件，以便审计和问题排查。

3. **权限管理和访问控制**：
   -  **权限表和token**：使用权限表来制定权限，使用jwt实现网络接口的访问控制

### 错误处理

1. **错误恢复和状态说明**：
   - **错误处理**：设计完善的错误处理机制，提供友好的错误信息和状态恢复选项，避免使用 `panic` 导致服务中断。
   - **用户提示**：为用户提供清晰的错误信息和建议，帮助他们理解问题并采取适当的行动。

2. **服务端日志记录**：
   - **日志策略**：制定详细的日志记录策略，包括记录级别（信息、警告、错误）和日志保存周期。
   - **监控和警报**：实施实时监控和警报系统，及时发现和响应服务异常或错误。

这些措施将有助于提升系统的安全性和稳定性。总体来看，你的设计已经涵盖了大部分关键领域，确保网络安全、数据安全以及错误处理的完整性。

### 操作的原子性和可回滚

#### 多数据库的仓库管理系统使用分布式数据管理来协调多节点

1. **分布式事务管理**：
- **两阶段提交协议 (2PC)**：包括两个阶段：准备阶段和提交阶段。在准备阶段，协调者询问所有参与者是否可以提交事务；在提交阶段，协调者根据所有参与者的反馈决定是否提交或回滚事务。

#### 单一节点的数据操作的原子性和可回滚

1. **事务管理**
- **SQLite 本身支持事务**，利用 SQLite 的事务机制来确保原子性。可以在多个数据库操作之间使用 BEGIN TRANSACTION 和 COMMIT / ROLLBACK 命令来确保操作的原子性。例如：

```Rust
let conn = Connection::open("database.db")?;
conn.execute("BEGIN TRANSACTION;", [])?;

// 执行多个数据库操作
conn.execute("INSERT INTO table1 (column1) VALUES (?);", [value1])?;
conn.execute("UPDATE table2 SET column2 = ? WHERE id = ?;", [value2, id])?;

// 如果所有操作成功
conn.execute("COMMIT;", [])?;
```

2. **对象关系映射（ORM）对事务管理的支持**ORM 框架提供了对事务的支持，包括：
  - **开始事务**：初始化一个新的事务。
  - **提交事务**：将事务中的所有操作持久化到数据库。
  - **回滚事务**：撤销事务中的所有操作，恢复到事务开始之前的状态。

#### 文件锁机制
1. **SQLite 使用文件锁来管理并发访问**:当多个进程尝试同时访问同一个数据库文件时，SQLite 使用以下锁级别来确保数据的安全性和一致性：
- **SHARED**: 允许多个读取操作，但禁止写入操作。
- **RESERVED**: 写入操作已预订，但仍然允许其他读取操作。
- **PENDING**: 将进行写入操作，禁止新的读取操作。
- **EXCLUSIVE**: 完全锁定数据库，禁止任何其他读取或写入操作。
通过这种锁机制，SQLite 能够避免数据竞争条件，确保在多进程、多线程的环境下，数据操作的安全性。

#### SQLite 的数据库文件访问权限
SQLite 使用底层的文件系统权限来管理对数据库文件的访问。这些权限通常由操作系统的文件系统来管理，通过设置文件的权限来控制对数据库文件的访问。

1. **文件权限管理**
SQLite 数据库文件权限受操作系统的文件权限控制。在 Unix-Like 系统上（如 Linux、macOS），可以使用 chmod 来管理文件的访问权限。
- **r**: 读取权限
- **w**: 写入权限
- **x**: 执行权限（不适用于数据库文件）
通过这些权限，SQLite 可以控制哪些用户和进程可以读取、写入数据库文件。

#### 可回滚
1. **在数据库表中记录每次提交的版本信息。**
2. **SQLite 的 WAL 模式文件**：当 SQLite 启用`WAL（Write-Ahead Logging）`模式时，会生成两个额外的文件
- **.wal 文件**：用于记录写入操作，以便在事务提交前缓冲。
- **.shm 文件**：用于协调多个进程间的内存共享。
以各个节点的日志为辅助，可以复原历史修改

### 部分功能

### 价格预算管理

### 1. **设计数据库结构**
   - **商品表（products）**：存储商品的基本信息，如商品名称、商品编号、单位价格、供应商等。
   - **预算表（budget）**：定义每个商品或商品类别的预算，包括预算总金额、使用金额、剩余金额、预算周期（如月度、季度、年度）。
   - **采购订单表（purchase_orders）**：记录每次采购的商品详情、数量、单价和总价。
   - **供应商表（suppliers）**：记录供应商信息，包括供应商名称、联系方式、历史交易记录等。

### 2. **定义价格预算处理逻辑**

#### 2.1 预算分配
在创建或修改商品时，分配每个商品的预算。通过系统界面，可以设定预算的起止日期和总预算金额。

#### 2.2 预算跟踪
每次生成采购订单时，系统自动检查预算，计算该商品的剩余预算是否足够：

- **检查预算是否充足**：判断预算剩余金额是否大于或等于当前采购的总金额。
- **预算更新**：如果预算充足，更新预算表中的`used_amount`和`remaining_amount`字段。

#### 2.3 预算预警
如果预算即将超出设定值，可以设置预警机制。比如，当某个商品的预算已使用超过80%时，系统发送通知或在界面上给出提示：

### 3. **UI 与交互设计**
- **预算管理界面**：提供一个界面，用户可以为不同商品设定预算，查看每个商品的预算使用情况和剩余预算。
- **采购订单处理界面**：在提交采购订单时，显示该订单是否超出预算，并给出处理方案（如调整订单数量、提交额外审批等）。
- **预算预警通知**：通过界面、邮件或短信等方式通知相关人员预算超额情况。

### 4. **集成供应商价格管理**
供应商的价格会影响到采购预算，因此系统需要跟踪每个供应商的历史报价，帮助优化采购决策。

- **价格比较功能**：当预算紧张时，系统自动推荐更优惠的供应商。
- **历史价格分析**：提供商品的历史价格趋势，帮助预测价格变动，合理分配预算。

### 5. **数据分析与报表**
提供预算执行情况的报表功能，按时间周期生成每个商品的预算使用报告，包括：

- **预算使用率**：显示已使用和剩余预算。
- **采购金额**：显示每次采购的金额和时间，方便分析预算分配是否合理。
- **预警历史**：记录每次预算超出预警的时间和商品。

### 6. **扩展功能**
- **审批流程**：对于超预算的采购订单，提供审批流程，需要管理员或财务人员审核并确认。
- **动态调整预算**：允许根据业务需求或市场波动情况，动态调整预算，并实时更新系统。

## 一些步骤和关键函数

### 1. 定义对象关系映射结构体

### 2. 引用模块和插件

### 3. 实现Trait

**注**

> cookies获取必须是同域请求

### 4. 定义行为等结构体

### 5. 数据库连接函数

调用后返回SqliteConnection结构,如果目标位置的嵌入式数据库文件不存在,则新建一个数据库.过程自动完成并且生成数据库所需的系统库嵌入到构建中.数据库连接函数只会在程序启动和初始化时使用,启动或初始化行为结束后即释放

### 6. 一些初始化函数

#### 6.1. 数据迁移函数

```
async fn run_db_migrations(conn: &mut SqliteConnection) {

    const MIGRATIONS: EmbeddedMigrations = embed_migrations!();

    if let Err(err) = conn.run_pending_migrations(MIGRATIONS) {

        error!("Error running migrations: {}", err);

    } else {

        info!("Database migrations executed successfully");

    }

}
```

通过调用此函数,在应用启动时自动依据嵌入的数据库迁移文件来运行数据迁移

#### 6.2. 本地节点初始化函数

```
// 获取名为"ThisWarehouse"的仓库ID MpHCXo8e0RfSru1kQQKoJawUgEUs9oYmktHPF+bT26o=

fn get_warehouse_id(

    conn: &mut SqliteConnection,

) -> Result<ed25519::Keypair, diesel::result::Error> {

    use self::warehouses::dsl::*;

    let warehouse: Warehouse = warehouses.filter(localkey.is_not_null()).first(conn)?;

    info!("Found warehouse: {:?}", warehouse.localkey);

    let mut local_key_bytes = if let Some(local_key) = &warehouse.localkey {

        general_purpose::STANDARD

            .decode(local_key)

            .expect("Base64 decode error")

    } else {

        Vec::new() // 或者其他默认值的处理

    };

    let keypair =

        ed25519::Keypair::decode(local_key_bytes.as_mut_slice()).expect("Keypair decode error");

    Ok(keypair)

}

  

fn generate_and_insert_new_local_key(conn: &mut SqliteConnection) -> ed25519::Keypair {

    let local_key = ed25519::Keypair::generate();

    let local_key_base64 = general_purpose::STANDARD.encode(local_key.encode());

    info!(

        "Generated and inserted new key {:?} for warehouse ThisWarehouse",

        local_key_base64

    );

    let local_peer_id = PeerId::from(PublicKey::Ed25519(local_key.public()));

    let new_warehouse = Warehouse {

        id: local_peer_id.to_string(),

        localkey: Some(local_key_base64),

        name: "ThisWarehouse".to_string(),

        location: "/ip4/127.0.0.1/tcp/8080".to_string(),

        created_at: Some(Utc::now().naive_utc()),

        updated_at: Some(Utc::now().naive_utc()),

    };

  

    use self::warehouses::dsl::*;

    diesel::insert_into(warehouses)

        .values(&new_warehouse)

        .execute(conn)

        .expect("Error inserting new warehouse");

  

    local_key

}
```

这里查找了数据库中本地节点的相关记录.
如果没有找到则会运行初始化

初始化过程包括生成ed25519密钥对,通过base64编码存入数据库本地节点记录中,从环境变量读取本地节点所在网络位置,存入数据库本地节点记录

程序启动时会读取密钥,依据公钥生成供其他节点认证的PeerID并打印到控制台,缓存私钥以供认证.

#### 6.3. 本地节点superuser初始化的行为

```rust
#[rocket::async_trait]

impl Fairing for AdminInit {

    fn info(&self) -> Info {

        Info {

            name: "Admin Initialization",

            kind: Kind::Ignite,

        }

    }

  

    async fn on_ignite(&self, rocket: Rocket<Build>) -> Result<Rocket<Build>, Rocket<Build>> {

        let db = DbConn::get_one(&rocket).await.expect("database connection");

  

        db.run(|c| {

            use self::administrators::dsl::*;

  

            let admin_count: i64 = administrators

                .count()

                .get_result(c)

                .expect("Error counting admins");

  

            if admin_count == 0 {

                let mut random_password = String::from("111");

  

                #[cfg(not(debug_assertions))]

                {

                    random_password = rand::thread_rng()

                        .sample_iter(&Alphanumeric)

                        .take(12)

                        .map(char::from)

                        .collect();

                }

  

                info!("默认管理员已创建，用户名: admin, 密码: {}", random_password);

                diesel::insert_into(administrators)

                    .values((

                        username.eq("admin"),

                        password.eq(random_password),

                        superuser.eq(true),

                    ))

                    .execute(c)

                    .expect("Error inserting admin");

            }

        })

        .await;

  

        Ok(rocket)

    }

}
```

首次启动rocket会通过此行为生成默认管理员,身份为superuser,并把登录信息写入启动日志来供用户连接.在debug构建中密码为111,在非debug构建中会使用随机密码.

### 路由功能的实现

#### 1. 登录和注册的 `options` 路由
- 处理登录和注册相关的请求，包括 CORS 配置和请求预检。

#### 2. 测试用路由
- 包括路由保护等功能的测试。
- 用于验证路由是否按照预期工作。

#### 3. 各种功能路由
- 路由中的数据库行为通过 Rocket 的数据连接池实现，而非直接调用数据库连接函数。
- 路由的返回值为 `Json<CustomResponder>`，这是一个定制的结构体，包含 HTTP 请求的状态和回应信息。

### 构建 Rocket

- 在 debug 构建中启用跨域资源共享（CORS）以方便调试。
- 在 release 构建中关闭 CORS 来增强安全性。
- 使用 Figment 嵌入式配置来设置连接池、端口等配置信息。

### `main` 函数

- 使用 Tokio 异步处理。
- 启动两个独立的异步任务：处理 P2P 网络行为的循环和 Rocket 监听。
  
  #### 主要步骤：
  
  1. 生成日志配置，监理日志记录文件，设置日志等级，初始化日志记录器。
  2. 设定两个日志记录器：一个用于终端输出，另一个用于日志文件。
  3. 根据启动和初始化函数中获取的记录和环境变量初始化本地节点身份和监听端口。
  4. 构建网络行为。
  5. 启动两个独立的异步任务来分别处理网络行为和 Rocket。
  6. 实现退出逻辑以确保平滑关闭。

# 前端

  

## 前端重点

  

- **界面美观**：确保用户界面视觉效果良好。

- **远程访问方便**：支持远程访问，确保操作的便捷性。

- **操作人性化**：优化用户操作流程，提升用户体验。

- **兼容性优良**：支持不同软件、平台和设备类型。

- **响应迅速**：提高界面响应速度，减少延迟。

- **本地化**：支持多语言和区域设置，适应不同用户需求。

  

## 使用 React 构建的前端（部分未完成）**

  

- **功能模块化**：通过编写和组织不同模块来丰富功能，同时保证代码的可读性、便于维护和扩展。

- **优化体验**：使用 framer-motion、nextui、antd 等库来优化用户体验。

  

# 部署

  

• **构建后部署**：通过 Rocket 嵌入部署前端应用，确保安全性和便捷性。
